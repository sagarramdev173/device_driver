# Interrupt

In Linux, interrupt signals are the distraction that diverts the processor to a new activity outside of the normal flow of execution. This new activity is called interrupt handler or interrupt service routine (ISR) and that distraction is Interrupts.

Interrupts are used in various devices to provide a means of interrupting the CPU.

## Polling vs Interrupts

| Polling | Interrupt |
|---------|-----------|
| In polling the CPU keeps on checking all the hardwares of the availability of any request. | In interrupt the CPU takes care of the hardware only when the hardware requests for some service. |
| The polling method is like a salesperson. The salesman goes from door to door while requesting to buy a product or service. Similarly, the controller keeps monitoring the flags or signals one by one for all devices and provides service to whichever component that needs its service. | An interrupt is like a shopkeeper. If one needs a service or product, he goes to him and apprises him of his needs. In case of interrupts, when the flags or signals are received, they notify the controller that they need to be serviced. |


## What will happen when the interrupt comes?

1. An electronic signal from the interrupt controller, which multiplexes multiple interrupt lines into a single line directed to the CPU. Upon detecting this signal, I suspend the current execution context.
2. The appropriate interrupt handler using the interrupt vector table. This handler identifies the source of the interrupt and executes the corresponding Interrupt Service Routine (ISR).
3. The ISR performs device-specific tasks such as reading device status registers, processing input/output data, and resetting device states. During this time, kernel may disable further interrupts to protect critical code regions.
4. As interrupts are asynchronous, kernel handle them with mechanisms to prioritize higher-priority interrupts. This may involve nested interrupts where higher-priority ISRs preempt lower-priority ones, ensuring minimal latency for critical operations.
5. After ISR execution, kernel re-enable interrupts if they were disabled, restore the original execution context, and resume the interrupted process. 

## Interrupts and Exceptions

Simple definitions of the two:

**Interrupts** – asynchronous interrupts generated by hardware.

**Exceptions** – synchronous interrupts generated by the processor.

System calls (one type of exception) on the x86 architecture are implemented by the issuance of a software interrupt, which traps into the kernel and causes the execution of a special system call handler. Interrupts work in a similar way, except hardware (not software) issues interrupts.

## Process Context and Interrupt Context

Kernel code running in process context is preemptible. An interrupt context, however, always runs to completion and is not preemptible. Because of this, there are restrictions on what can be done from an interrupt context.   

**Code executing from interrupt context cannot do the following**:

Go to sleep or relinquish the processor  
Acquire a mutex  
Perform time-consuming tasks  
Access user space virtual memory  

To eliminate that problem, the processing of interrupts is split into two parts or halves:

1. Top halves
2. Bottom halves

## Top halves and Bottom halves

**Top halves**  
The interrupt handler is the top half. The top half will run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.

**Bottom half**  
The bottom half is used to process data, letting the top half to deal with new incoming interrupts. Interrupts are enabled when a bottom half runs.

There are 4 bottom half mechanisms are available in Linux:

1. Workqueue
2. Threaded IRQs
3. Softirq
4. Tasklets


## Before writing any interrupt program, you should keep the following points in mind.

1. Interrupt handlers **can not enter sleep**, so to avoid calls to some functions which has sleep.  

2. When the interrupt handler has part of the code to enter the critical section, **use spinlocks, rather than mutexes**. Because if it can’t take mutex it will go to sleep until it takes the mute.  

3. Interrupt handlers **can not exchange data with the userspace**.

4. The interrupt handlers **must be executed as soon as possible**. To ensure this, it is best to split the implementation into two parts, the top half and the bottom half. The top half of the handler will get the job done as soon as possible and then work late on the bottom half, which can be done with softirq or tasklet or workqueue.  

5. Interrupt handlers **can not be called repeatedly**. When a handler is already executing, its corresponding IRQ must be disabled until the handler is done. 
 
6. Interrupt handlers **can be interrupted by higher authority handlers**. If you want to avoid being interrupted by a highly qualified handler, you can mark the interrupt handler as a fast handler. However, if too many are marked as fast handlers, the performance of the system will be degraded because the interrupt latency will be longer.

## Writing interrupt driver    

**Registering an Interrupt Handler**

``` C
#define IRQ_NO 11

if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, "demo_device", (void *)(irq_handler))) {
            printk(KERN_INFO "my_device: cannot register IRQ ");
            goto irq;
}
```
**Freeing an Interrupt Handler**
``` C
free_irq(IRQ_NO,(void *)(irq_handler));
```
**Interrupt Handler**
```C
static irqreturn_t irq_handler(int irq,void *dev_id) {
  printk(KERN_INFO "Shared IRQ: Interrupt Occurred");
  return IRQ_HANDLED;
}
```